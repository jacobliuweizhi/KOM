import os as _os
import cv2 as _cv
import numpy as _np
import pandas as _pd
import torch as _t
import torch.nn.functional as _F
import torchvision.models as _vm
from torch import nn as _nn
from torchvision import transforms as _tf
import re as _re

class A1(_nn.Module):
    def __init__(self):
        super(A1, self).__init__()
        self.l1 = self._blk(1, 64)
        self.l2 = self._blk(64, 128)
        self.l3 = self._blk(128, 256)
        self.l4 = self._blk(256, 512)
        self.l5 = self._blk(512, 1024)
        self.u4 = _nn.ConvTranspose2d(1024, 512, 2, 2)
        self.d4 = self._blk(1024, 512)
        self.u3 = _nn.ConvTranspose2d(512, 256, 2, 2)
        self.d3 = self._blk(512, 256)
        self.u2 = _nn.ConvTranspose2d(256, 128, 2, 2)
        self.d2 = self._blk(256, 128)
        self.u1 = _nn.ConvTranspose2d(128, 64, 2, 2)
        self.d1 = self._blk(128, 64)
        self.out = _nn.Conv2d(64, 1, 1)

    def _blk(self, i, o):
        return _nn.Sequential(
            _nn.Conv2d(i, o, 3, padding=1),
            _nn.BatchNorm2d(o),
            _nn.ReLU(True),
            _nn.Conv2d(o, o, 3, padding=1),
            _nn.BatchNorm2d(o),
            _nn.ReLU(True),
        )

    def forward(self, x):
        a1 = self.l1(x)
        a2 = self.l2(_F.max_pool2d(a1, 2))
        a3 = self.l3(_F.max_pool2d(a2, 2))
        a4 = self.l4(_F.max_pool2d(a3, 2))
        b  = self.l5(_F.max_pool2d(a4, 2))
        y4 = self.u4(b); y4 = self.d4(_t.cat((y4, a4),1))
        y3 = self.u3(y4); y3 = self.d3(_t.cat((y3, a3),1))
        y2 = self.u2(y3); y2 = self.d2(_t.cat((y2, a2),1))
        y1 = self.u1(y2); y1 = self.d1(_t.cat((y1, a1),1))
        return _t.sigmoid(self.out(y1))

_base_dir = r'/project/data'
_modelA_path = _os.path.join(_base_dir, 'moduleA', 'modelA_v1.pth')
_modelB_path = _os.path.join(_base_dir, 'moduleB', 'modelB_v1.pth')

print('>> Loading UNet A <<')
_modA = A1().to('cuda' if _t.cuda.is_available() else 'cpu')
_modA.load_state_dict(_t.load(_modelA_path, weights_only=True)); _modA.eval()
print('>> UNet A loaded <<')
print('>> Loading UNet B <<')
_modB = A1().to('cuda' if _t.cuda.is_available() else 'cpu')
_modB.load_state_dict(_t.load(_modelB_path, weights_only=True)); _modB.eval()
print('>> UNet B loaded <<')

def L2(path):
    print(f'>> Loading ResNet from {path} <<')
    m = _vm.resnet50(weights=_vm.ResNet50_Weights.DEFAULT)
    feat = m.fc.in_features
    ck = _t.load(path, weights_only=True)
    out_s = ck['fc.weight'].shape[0]
    m.fc = _nn.Linear(feat, out_s)
    m.conv1 = _nn.Conv2d(1, 64, 7, 2, 3, False)
    m.load_state_dict(ck)
    m = m.to('cuda' if _t.cuda.is_available() else 'cpu')
    m.eval()
    print(f'>> ResNet from {path} ready <<')
    return m

_subtags = ['T01','T02','T03','T04','T05','T06','T07','T08','T09','T10','T11']
_class_dir = _os.path.join(_base_dir, 'class_models')
_R = {}
for tag in _subtags:
    fp = _os.path.join(_class_dir, tag, f'{tag}_best.pth')
    if _os.path.exists(fp):
        _R[tag] = L2(fp)
    else:
        print(f'Warning: missing {fp}')

_img_root = _os.path.join(_base_dir, 'images')
_out_csv = _os.path.join(_base_dir, 'results', 'summary.csv')

def F1(m):
    cnt,_ = _cv.findContours(m, _cv.RETR_EXTERNAL, _cv.CHAIN_APPROX_SIMPLE)
    return [(
        int(_cv.moments(c)['m10']/_cv.moments(c)['m00']),
        int(_cv.moments(c)['m01']/_cv.moments(c)['m00'])
    ) for c in cnt if _cv.moments(c)['m00']]

def F2(img, cts):
    lst=[]
    for x,y in cts:
        x0,x1 = max(x-96,0), min(x+96, img.shape[1])
        y0,y1 = max(y-96,0), min(y+96, img.shape[0])
        cp = _cv.resize(img[y0:y1, x0:x1], (512,512))
        lst.append((cp, x))
    return lst

def P1(fp):
    print(f'>> Processing {fp} <<')
    fn = _os.path.basename(fp)
    fn_clean = _re.sub(r'[\^\s]', '', fn)
    if 'OAIXRAYSCREENINGKNEE' not in fn_clean:
        return None, None
    pid = fn_clean.split('_')[0]
    im = _cv.imread(fp, _cv.IMREAD_GRAYSCALE)
    if im is None:
        return None, None
    h,w = im.shape[:2]
    if min(h,w) != 512:
        r = 512.0/min(h,w)
        nh, nw = int(h*r), int(w*r)
        im = _cv.resize(im, (nw, nh))
        cx, cy = nw//2, nh//2
        im = im[cy-256:cy+256, cx-256:cx+256]
    t = _tf.ToTensor()(im).unsqueeze(0).to('cuda' if _t.cuda.is_available() else 'cpu')
    try:
        mA = (_modA(t).squeeze().cpu().numpy()>0.3).astype(_np.uint8)*255
    except RuntimeError:
        return None, None
    mB = (_modB(t).squeeze().cpu().numpy()>0.3).astype(_np.uint8)*255
    cA, cB = F1(mA), F1(mB)
    cts = cA if len(cA)>=len(cB) else cB
    cps = F2(im, cts)
    res = {}
    for name, md in _R.items():
        tmp = {'L':None, 'R':None}
        for cp, x in cps:
            side = 'L' if x < mA.shape[1]//2 else 'R'
            out = md(_tf.ToTensor()(cp).unsqueeze(0).to('cuda' if _t.cuda.is_available() else 'cpu'))
            tmp[side] = int(_t.argmax(out,1).cpu().item())
        res[name] = tmp
    return pid, res

_df = _pd.DataFrame(columns=['Patient'])
for root, _, files in _os.walk(_img_root):
    for f in files:
        pid, result = P1(_os.path.join(root, f))
        if not pid:
            continue
        row = {'Patient': pid}
        for nm, sides in result.items():
            for sd, val in sides.items():
                row[f'{nm}_{sd}'] = val
        _df = _pd.concat([_df, _pd.DataFrame([row])], ignore_index=True)
_df.to_csv(_out_csv, index=False)
print(f'>> Results saved to {_out_csv} <<')
