import pickle as _pk
import pandas as _pd
import numpy as _np
import torch as _t
import torch.nn as _nn
from pathlib import Path as _P
from sklearn.preprocessing import StandardScaler as _SS

_CFG = {
    'data_file': _P('/data/inputs/merged.csv'),
    'models_dir': _P('/models/dnn'),
    'output_file': _P('/data/outputs/preds.csv'),
    'output_adj_file': _P('/data/outputs/preds_adj.csv'),
    'continuous': [
        'V00AGE','P01BMI','P01WEIGHT','V00rfmaxf','V00remaxf','V00lfmaxf','V00lemaxf',
        'V00KOOSKPR','V00KOOSYMR','V00KOOSKPL','V00KOOSYML','V00KOOSFSR','V00KOOSQOL',
        'V00rfmaxf_norm_BMI','V00remaxf_norm_BMI','V00lfmaxf_norm_BMI','V00lemaxf_norm_BMI'
    ],
    'classification_targets': [
        'V01XRKL_Left','V01XRKL_Right','V06XRKL_Left','V06XRKL_Right'
    ],
    'adjust_cols': ['V00rfmaxf','V00remaxf','V00lfmaxf','V00lemaxf'],
    'adjust_factor': 1.3
}
device = _t.device('cuda' if _t.cuda.is_available() else 'cpu')

def _load(p, feats):
    df = _pd.read_csv(p)
    df['ID'] = df['ID'].astype(str).str.replace("b'","").str.replace("'","").astype(int)
    miss = set(feats) - set(df.columns)
    for m in miss: df[m] = 0
    df = df.replace([_np.inf, -_np.inf], _np.nan).fillna(df.mean())
    X = df[feats].values
    scl = _SS().fit(X)
    return df['ID'].values, scl.transform(X), scl

def _init_net(inp):
    class M(_nn.Module):
        def __init__(self):
            super().__init__()
            self.n = _nn.Sequential(
                _nn.Linear(inp,256), _nn.BatchNorm1d(256), _nn.Mish(), _nn.Dropout(0.3),
                _nn.Linear(256,128), _nn.BatchNorm1d(128), _nn.Mish(), _nn.Dropout(0.3),
                _nn.Linear(128,64),  _nn.BatchNorm1d(64),  _nn.Mish(), _nn.Dropout(0.3),
                _nn.Linear(64,32),   _nn.BatchNorm1d(32),   _nn.Mish(), _nn.Dropout(0.3),
                _nn.Linear(32,1)
            )
        def forward(self, x): return self.n(x)
    return M().to(device)

def _predict(ids, X, scl):
    feats = _CFG['continuous']
    targets = _CFG['classification_targets']
    adj = np.array([_CFG['adjust_factor'] if f in _CFG['adjust_cols'] else 1 for f in feats]).reshape(1,-1)
    X_adj = X * adj
    preds, preds_adj = {}, {}
    for t in targets:
        mp = _CFG['models_dir']/t/f'{t}.pth'
        if mp.exists():
            m = _init_net(X.shape[1])
            sd = _t.load(mp, map_location=device, weights_only=True) if hasattr(_t,'__version__') and int(_t.__version__.split('.')[1])>=9 else _t.load(mp, map_location=device)
            m.load_state_dict(sd); m.eval()
            xt = _t.tensor(X, dtype=_t.float32).to(device)
            xa = _t.tensor(X_adj, dtype=_t.float32).to(device)
            with _t.no_grad():
                preds[t] = m(xt).cpu().numpy().squeeze()
                preds_adj[t] = m(xa).cpu().numpy().squeeze()
    df1 = _pd.DataFrame({'ID': ids, **preds})
    df2 = _pd.DataFrame({'ID': ids, **preds_adj})
    df1.to_csv(_CFG['output_file'], index=False)
    df2.to_csv(_CFG['output_adj_file'], index=False)

if __name__=='__main__':
    cols = _CFG['continuous'] + _CFG['classification_targets']
    ids, X, scl = _load(_CFG['data_file'], cols)
    _predict(ids, X, scl)
    print('>> Done <<')
